<h1>Parcial - tema2</h1>
<p>Nota: 9.0 / 10.0 (APROBADO)</p>
<pre><code>puntaje ej1: 2
puntaje ej2: 2
puntaje ej3: 2
puntaje ej4: 3
puntaje ej5: 0.0
</code></pre>
<h2>Datos del alumno</h2>
<p>Nombre: Franco Monterubbianesi</p>
<p>DNI: 37989929</p>
<p>LU: 415/21</p>
<p>Maquina: 63-05</p>
<h2>Enunciado</h2>
<html>

<head>
  <link rel="icon" href="data:,">
  <link href="css/style.css" rel="stylesheet" />
</head>

<body>

<div>

<h1> Parcial Haskell - Tema 1 </h1>

<p>

<h2> Importante </h2>
Template de funciones a implementar <a href="#" onclick="forceDownload('../parcial/Template_t1.hs','SolucionT1.hs');">aca</a><br>
Lista de funciones permitidas <a href="/static/haskell_permitidas.html">aca</a><br>
Ejemplo de hunit <a href="#" onclick="forceDownload('../parcial/Test_template_t1.hs','Test_template_t1.hs');">aca</a>

<p>

<form name="form1" action="/submit_examen" method="post" enctype="multipart/form-data" onsubmit="return validaciones(event)">

<h2> Enunciado </h2>

<ol>
 <p>
  Resolver los siguientes ejercicios cuyas especificaciones en lenguaje
  semiformal figuran a continuación. Deben ser implementadas en Haskell utilizando los tipos
  requeridos y solamente las funciones que se ven en la materia Introducción a la Programación / Algoritmos y Estructuras de Datos I (FCEyN-UBA).
</p>

<li> <strong>Ejercicio 1 (2 puntos)</strong></li>
<p>problema maxMovilN (lista: seq⟨Z⟩, n: Z) : Z {<br>
  &nbsp; <strong>requiere:</strong> {|<i>lista</i>| > 0} <br>
  &nbsp; <strong>requiere:</strong> {n > 0 y n es menor a la longitud de la <i>lista</i>} <br>
  &nbsp; <strong>asegura:</strong> {<i>res</i> es el máximo de los últimos <i>n</i> elementos de <i>lista</i>.} <br>
}<br>
</p>

  <li> <strong>Ejercicio 2 (2 puntos)</strong></li>
  <p>problema promedioPrimo (<i>n</i>: Z) : Float {<br>
    &nbsp; <strong>requiere:</strong> {n > 1} <br>
    &nbsp; <strong>asegura:</strong> {(<i>res</i> es el promedio de todos los factores primos de n (distintos o no).} <br>
    }<br>

    <p>Aclaración: los factores primos de 30 son [5,3,2]. Los factores primos de 9 son [3,3].
  </p>

  <li> <strong>Ejercicio 3 (2 puntos)</strong></li>
  <p>problema letrasIguales (<i>palabra</i>: seq⟨Char⟩) : Z {<br>
    &nbsp; <strong>requiere:</strong> {True} <br>
    &nbsp; <strong>asegura:</strong> {(<i>res</i> es la cantidad de caracteres no blancos repetidos en <i>palabra</i>.} <br>
    }<br>
  </p>

  <li> <strong>Ejercicio 4 (3 puntos)</strong></li>
  <p>problema  cuantosIguales (<i>palabra1</i>: seq⟨Char⟩, <i>palabra2</i>: seq⟨Char⟩) : Z⟩{<br>
    &nbsp; <strong>requiere:</strong> {True}<br>
    &nbsp; <strong>asegura:</strong> {<i>res</i> es igual a la cantidad de caracteres no blancos y distintos que <i>palabra1</i> y <i>palabra2</i> tienen en común.} <br>
  }<br>
  </p>

  <li> <strong>Ejercicio 5 (1 punto)</strong></li>
  <p>
    ¿Cuál de las siguientes afirmaciones es correcta sobre el uso de pattern matching en Haskell? <br>

  <input type="radio" name="mchoice_1" id="opcion1" value="1" />
      <label for="opcion1">Pattern matching en Haskell solo se utiliza con listas y tuplas.</label> <br>
  <input type="radio" name="mchoice_1" id="opcion2" value="2" />
      <label for="opcion2">Pattern matching en Haskell permite seleccionar qué cláusula de una definición de función ejecutar según la forma de los parámetros.</label> <br>
  <input type="radio" name="mchoice_1" id="opcion3" value="3" />
      <label for="opcion3">Pattern matching en Haskell siempre debe manejar todas las posibles combinaciones de patrones, de lo contrario, el compilador lanzará un error.</label> <br>
  </p>

</ol>

<hr>
  <h3 style="color:#1A5276">Adjunta el archivo con tu solución:</h3>
  <p><b style="color:red">Solo se puede adjuntar 1 archivo de extensión .hs. En caso de haber desarrollado tests propios, no deben ser entregados.</b></p>

  <label for="archivo">Seleccionar archivo a enviar:</label>
  <input type="file" id="archivo" name="archivo" required accept=".hs,text/x-haskell"/>

  <input type="submit" value="Enviar"
        style= "background-color: #1A5276; border-radius: 5px;
                margin-top:10px;padding: 10px 150px;color: #FFFFFF;
                font-size: 20px;cursor: pointer; width:100%" >

</form>

</div>

<script>
  function validaciones(event) {
    var confirmacion = confirm("Confirmo que revise mis respuestas y que quiero entregar mi examen");
    if (!confirmacion) {
        event.preventDefault();
        event.returnValue = false;
        return false;
      }
      event.returnValue = true;
      return true;
  }
</script>

<script>
// registro una funcion para mostrar el archivo cuando se adjunta.
// de esa forma evitamos que se adjunten otros archivos por error
document
  .getElementById('archivo')
  .addEventListener(
      'change',
      function () {
          var fr = new FileReader();
          fr.onload = function () {
              alert(this.result);
          };
          fr.readAsText(this.files[0]);
      }
  );

// para forzar a bajar el template de hunit y que no se pueda abrir en un nuevo tab
// (el browser intenta mostrar el codigo como HTML y el formato se ve raro)
function forceDownload(url, filename) {
  fetch(url).then(function(t) {
    return t.blob().then((b) => {
      var a = document.createElement("a");
      a.href = URL.createObjectURL(b);
      a.setAttribute("download", filename);
      a.click();
    });
  });
}
</script>

</body>

</html>

<h2>Solucion entregada por el alumno</h2>
<pre><code>module SolucionT1 where
--------------------------------------------------------------------------------------------------------------------------------------------------

-- Ejercicio 1
maxMovilN :: [Integer] -&gt; Integer -&gt; Integer
maxMovilN list n = obtenerMaximo (obtenerLosUltimosN list n)

obtenerLosUltimosN :: [Integer] -&gt; Integer -&gt; [Integer]
obtenerLosUltimosN [] _ = []
obtenerLosUltimosN [x] _ = [x]
obtenerLosUltimosN list n | longitud list == n = list
                          | otherwise = obtenerLosUltimosN (tail list) n

longitud :: [Integer] -&gt; Integer
longitud [] = 0
longitud list = 1 + longitud (tail list) 

obtenerMaximo :: [Integer] -&gt; Integer
obtenerMaximo [] = 0
obtenerMaximo [x] = x
obtenerMaximo (x:xs) | x &gt; head xs = obtenerMaximo (x : tail xs)
                     | otherwise = obtenerMaximo xs

--------------------------------------------------------------------------------------------------------------------------------------------------

 -- Ejercicio 2
promedioPrimo :: Integer -&gt; Float
promedioPrimo n = fromInteger (sumatoriaDeElementos (factoresPrimosDeN n 2)) / fromInteger (longitud (factoresPrimosDeN n 2))

sumatoriaDeElementos :: [Integer] -&gt; Integer
sumatoriaDeElementos [] = 0
sumatoriaDeElementos [x] = x
sumatoriaDeElementos (x:xs) = x + sumatoriaDeElementos xs

factoresPrimosDeN :: Integer -&gt; Integer -&gt; [Integer]
factoresPrimosDeN n k | n == 1 = []
                      | esPrimo (menorDivisor n k) = menorDivisor n k : factoresPrimosDeN (div n (menorDivisor n k)) k
                      | otherwise = factoresPrimosDeN n k

esPrimo :: Integer -&gt; Bool
esPrimo 1 = False
esPrimo 2 = True
esPrimo n = menorDivisor n 2 == n

menorDivisor :: Integer -&gt; Integer -&gt; Integer
menorDivisor 1 _ = 1
menorDivisor n k | mod n k == 0 = k
                 | otherwise = menorDivisor n (k+1)

--------------------------------------------------------------------------------------------------------------------------------------------------

-- Ejercicio 3
letrasIguales :: String -&gt; Integer
letrasIguales [] = 0
letrasIguales (x:xs) | x == ' ' = letrasIguales xs
                     | estaRepetidoCaracterX x (eliminarBlancos xs) = 1 + letrasIguales (eliminarCaracterX xs x)
                     | otherwise = letrasIguales xs

estaRepetidoCaracterX :: Char -&gt; String -&gt; Bool
estaRepetidoCaracterX _ [] = False
estaRepetidoCaracterX c (x:xs) | c == x = True
                               | otherwise = estaRepetidoCaracterX c xs

eliminarCaracterX :: String -&gt; Char -&gt; String
eliminarCaracterX [] _ = []
eliminarCaracterX (x:xs) c | x == c = eliminarCaracterX xs c
                           | otherwise = x : eliminarCaracterX xs c 

eliminarBlancos :: String -&gt; String
eliminarBlancos [] = []
eliminarBlancos (x:xs) | x == ' ' = eliminarBlancos xs
                       | otherwise = x : eliminarBlancos xs

--------------------------------------------------------------------------------------------------------------------------------------------------

-- Ejercicio 4
cuantosIguales :: String -&gt; String -&gt; Integer
cuantosIguales [] [] = 0
cuantosIguales _ [] = 0
cuantosIguales [] _ = 0
cuantosIguales palabra1 palabra2 | head palabra1 == ' ' = cuantosIguales (eliminarBlancos palabra1) (eliminarBlancos palabra2)
                                 | head palabra2 == ' ' = cuantosIguales (eliminarBlancos palabra1) (eliminarBlancos palabra2)
                                 | estaRepetidoCaracterX (head palabra1) palabra2 = 1 + cuantosIguales (eliminarCaracterX palabra1 (head palabra1)) (eliminarCaracterX palabra2 (head palabra1))  
                                 | otherwise = cuantosIguales (tail palabra1) palabra2


</code></pre>
<h2>Resultado de la compilacion</h2>
<pre><code>Loaded package environment from /home/ignacio/.ghc/x86_64-linux-9.4.7/environments/default
[1 of 1] Compiling SolucionT1       ( correcciones/haskell-tn/monterubbianesi_franco_37989929/submission.hs.main.hs, correcciones/haskell-tn/monterubbianesi_franco_37989929/submission.hs.main.o )

</code></pre>
<h2>Ejecucion de los tests</h2>
<h3>tema2-test-ej1.hs.compilacion.out</h3>
<p>Puntaje del ej: 2 / 2</p>
<pre><code>


Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0


Cases: 10  Tried: 10  Errors: 0  Failures: 0

</code></pre>
<h3>tema2-test-ej2.hs.compilacion.out</h3>
<p>Puntaje del ej: 2 / 2</p>
<pre><code>


Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0


Cases: 6  Tried: 6  Errors: 0  Failures: 0

</code></pre>
<h3>tema2-test-ej3.hs.compilacion.out</h3>
<p>Puntaje del ej: 2 / 2</p>
<pre><code>


Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0


Cases: 6  Tried: 6  Errors: 0  Failures: 0

</code></pre>
<h3>tema2-test-ej4.hs.compilacion.out</h3>
<p>Puntaje del ej: 3 / 3</p>
<pre><code>


Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0



Cases: 1  Tried: 1  Errors: 0  Failures: 0


Cases: 6  Tried: 6  Errors: 0  Failures: 0

</code></pre>
<h3>mchoice.json-ej5.compilacion.out</h3>
<p>Puntaje del ej: 0.0 / 1</p>
<pre><code>mchoice ej5: respuesta del alumno=3, respuesta correcta=2

Ran 1 test in 0 seconds

FAILED (failures=1)

</code></pre>
<p>FIN</p>