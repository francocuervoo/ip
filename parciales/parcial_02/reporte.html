<h1>Parcial - tema1</h1>
<p>Nota: 10.0 / 10.0 (APROBADO)</p>
<pre><code>puntaje ej1: 2.25
puntaje ej2: 2.25
puntaje ej3: 2.25
puntaje ej4: 2.25
puntaje ej5: 1
</code></pre>
<h2>Datos del alumno</h2>
<p>Nombre: Franco Monterubbianesi</p>
<p>DNI: 37989929</p>
<p>LU: 415/21</p>
<p>Maquina: 36-04</p>
<h2>Enunciado</h2>
<!doctype html>
<html>
<head>
  <link rel="icon" href="data:,">
  <link href="css/style.css" rel="stylesheet" />
  <meta charset="UTF-8">
  <style>
    th, td {
        border: 1px solid black;
        padding: 10px;
        text-align: left;
    }
    th {
        background-color: #f2f2f2;
    }
    .conditions {
        margin-left: 20px;
    }
</style>
</head>

<body style="width: 50%;margin: 1% auto;">

<div> 
<h1> Parcial Python - Tema 1 </h1>

<h2> Importante </h2>

<ul>
  <li>El parcial se aprueba con 6 puntos</li>
  <li>Template de funciones a implementar <a href="#" onclick="forceDownload('/parcial/Template_t1.py','Template_t1.py');">acá</a><br></li>
  <li>Lista de funciones permitidas <a href="/static/python_permitidas.html">acá</a></li>
  <li>Para testear el código pueden usar <a href="#" onclick="forceDownload('/parcial/tema1-test.py', 'tema1-test.py')">este</a> archivo que ya cuenta con todo lo necesario para desarrollar sus propios tests (este archivo no se entrega)</li>
</ul>

Implementar las siguientes especificaciones en Python.

<form name="form1" action="/submit_examen" method="post" enctype="multipart/form-data" onsubmit="return validaciones(event)">

  <hr style="width: 100%;">
  <h3 style="color:#1A5276">1) Ejercicio 1 [2.25 puntos]</h3>

<p> problema multiplos_de_primos (in <i>v</i>: seq⟨Z⟩) : Diccionario⟨Z, Z⟩ {<br>
  &nbsp; <strong>requiere:</strong> { Los elementos de <i>v</i> son positivos }<br>

  &nbsp; <strong>asegura:</strong> { Las claves de <i>res</i> son números primos, y cada valor corresponde con la cantidad de números en <i>v</i> tales que ese primo lo divide }<br>
  &nbsp; <strong>asegura:</strong> { Si existe un número primo p tal que divide a algún número de <i>v</i>, entonces p es clave de <i>res</i> }<br>
  &nbsp; <strong>asegura:</strong> { Los valores de <i>res</i> son positivos }<br>
}<br>
</p>

  <hr style="width: 100%;">
  <h3 style="color:#1A5276">2) Ejercicio 2 [2.25 puntos] </h3>

<p> problema longitud_mas_grande (in <i>A</i>: seq⟨seq⟨Z⟩⟩) : Z {<br>
  &nbsp; <strong>requiere:</strong>{  Hay al menos un uno en <i>A</i>  }<br>
  &nbsp; <strong>asegura:</strong> { Sea v la secuencia de unos más larga que está contenida en algún <i>A[i]</i> para i válido, res es igual a la longitud de v }<br>
  }<br>
</p>

<p>

  <hr style="width: 100%;">
  <h3 style="color:#1A5276">3) Ejercicio 3 [2.25 puntos]</h3>

Implementar la especificación <i>resolver_cuentas</i> descrita a continuación.

<p> problema resolver_cuentas(in <i>p</i>: Pila⟨string⟩ ) : seq⟨Z⟩ {<br>
  &nbsp; <strong>requiere:</strong> { Para cada elemento x de <i>p</i> vale esta_bien_formado(x) }<br>
  &nbsp; <strong>asegura:</strong> { <i>res[i]</i> es igual al resultado de la operación aritmética representada por el tope de la pila <i>p</i> luego de haber desapilado i elementos, para 0 <= i < longitud de <i>p</i> }<br>
  &nbsp; <strong>asegura:</strong> { <i>res</i> tiene la misma cantidad de elementos que <i>p</i> }<br>
  }<br>
  </p>

<p> problema esta_bien_formado(in <i>s</i>: string) : Bool {<br>
  &nbsp; <strong>requiere:</strong> { - }<br>
  &nbsp; <strong>asegura:</strong> { res == True <==> Cada caracter de s es '+', '-' o es un dígito; el último caracter de <i>s</i> es un dígito; no hay dos operadores consecutivos en <i>s</i> (los operadores son '+' y '-') }<br>
  }<br>
</p>

  <hr style="width: 100%;">
  <h3 style="color:#1A5276">4) Ejercicio 4 [2.25 puntos]</h3>

<p> problema dame_el_que_falta (in <i>s</i>: seq⟨ZxZ⟩): ZxZ {<br>
  &nbsp; <strong>requiere:</strong> { El menor número que aparece en alguna tupla de <i>s</i> es igual a 1 }<br>
  &nbsp; <strong>requiere:</strong> { Sea n el máximo número que aparece en alguna tupla de <i>s</i>, |s| = n*n-1 }<br>
  &nbsp; <strong>requiere:</strong> { <i>s</i> no tiene tuplas repetidas }<br>
  &nbsp; <strong>asegura:</strong> { Las compontentes de <i>res</i> son valores entre 1 y n, inclusive }<br>
  &nbsp; <strong>asegura:</strong> { <i>res</i> no pertenece a <i>s</i> }<br>
  }<br>
  </p>

<hr style="width: 100%;">
  <h3 style="color:#1A5276">5) Pregunta teórica (1 punto)</h3>

  <p>Conteste marcando la opción correcta.</p>

      <h4 style="color:#1A5276">En el contexto de Testing de Caja Blanca ¿Qué diferencia hay entre cubrimiento de arcos y cubrimiento de decisiones o ramas? </h4>

     <p>
      <input type="radio" name="mchoice_1" id="Bopcion1" value="1" />
          <label for="Bopcion1">No hay diferencia, ambos se refieren al mismo concepto</label> <br>
      <input type="radio" name="mchoice_1" id="Bopcion2" value="2" />
          <label for="Bopcion2">El cubrimiento de arcos verifica las instrucciones del programa, mientras que cubrimiento de ramas verifica cada arco del Grafo de Control de Flujo (CGF) del programa</label> <br>
      <input type="radio" name="mchoice_1" id="Bopcion3" value="3" />
          <label for="Bopcion3">El cubrimiento de arcos verifica los arcos del Grafo de Control de Flujo (CFG), mientras que cubrimiento de ramas verifica cada arco True o False de cada decisión lógica del programa</label> <br>
      </p>

  <hr style="width: 100%;">
  <h3 style="color:#1A5276">Adjunta el archivo con tu solución:</h3>
  <p><b style="color:red">Solo se puede adjuntar 1 archivo de extensión .py. En caso de haber desarrollado tests propios, no deben ser entregados.</b></p>

  <label for="archivo">Seleccionar archivo a enviar:</label>
  <input type="file" id="archivo" name="archivo" required accept=".py,text/x-python"/>

  <input type="submit" value="Enviar"
        style= "background-color: #1A5276; border-radius: 5px;
                margin-top:10px;padding: 10px 150px;color: #FFFFFF;
                font-size: 20px;cursor: pointer; width:100%" >

</form>
</div>
<script>
  function validaciones(event) {
    // Obtiene todos los inputs tipo radio del formulario
      const radioGroups = document.querySelectorAll('input[type="radio"]');
      const groupedByName = {};

      // Agrupar radios por su atributo name
      radioGroups.forEach(radio => {
        if (!groupedByName[radio.name]) {
          groupedByName[radio.name] = [];
        }
        groupedByName[radio.name].push(radio);
      });

      // Verificar que cada grupo de radios tenga al menos uno seleccionado
      for (const groupName in groupedByName) {
        const radios = groupedByName[groupName];
        const isChecked = radios.some(radio => radio.checked);

        if (!isChecked) {
          alert(`Debes seleccionar una opción para la pregunta ${groupName}`);
          return false; // Detener la validación si falta alguna opción
        }
      }

      var confirmacion = confirm("Confirmo que revisé mis respuestas y que quiero entregar mi examen");
      if (!confirmacion) {
          event.preventDefault();
          event.returnValue = false;
          return false;
        }
        event.returnValue = true;
        return true;
    }

// registro una funcion para mostrar el archivo cuando se adjunta.
// de esa forma evitamos que se adjunten otros archivos por error
document
  .getElementById('archivo')
  .addEventListener(
      'change',
      function () {
          var fr = new FileReader();
          fr.onload = function () {
              alert(this.result);
          };
          fr.readAsText(this.files[0]);
      }
  );

// para forzar a bajar el template de pytest y que no se pueda abrir en un nuevo tab
// (el browser intenta mostrar el codigo como HTML y el formato se ve raro)
function forceDownload(url, filename) {
  fetch(url).then(function(t) {
    return t.blob().then((b) => {
      var a = document.createElement("a");
      a.href = URL.createObjectURL(b);
      a.setAttribute("download", filename);
      a.click();
    });
  });
}
</script>
</body>

</html>

<h2>Solucion entregada por el alumno</h2>
<pre><code>from queue import Queue as Cola
from queue import LifoQueue as Pila

# Ejercicio 1
def multiplos_de_primos(v: list[int]) -&gt; dict[int,int]:
    lista_parcial : list[list[int]] = []
    res : dict[int,int] = dict()

    for u in v:
        lista_parcial.append(obtener_primos_que_dividen(u))

    lista_unificada : list[int] = unificar_lista(lista_parcial)

    for numero in lista_unificada:
        res[numero] = 0

    for dictKey , dictValue in res.items():
        res[dictKey] = cantidad_de_veces_que_dividie(dictKey, v)

    return res

def es_primo ( numero : int) -&gt; bool:
    if numero &lt; 2:
        return False

    contador : int = 2

    while not contador == numero:
        if numero % contador == 0:
            return False
        else:
            contador += 1

    return True

def obtener_primos_que_dividen ( numero : int) -&gt; list[int]:
    lista_primos : list[int] = []

    numero_primo : int = 2

    while not numero_primo &gt; numero:
        if es_primo(numero_primo) and numero % numero_primo == 0:
            lista_primos.append(numero_primo)
        numero_primo += 1

    return lista_primos

def unificar_lista ( lista_numeros : list[list[int]]) -&gt; list[int]:
    nueva_lista : list[int] = []

    for lista in lista_numeros:
        for numero in lista:
            if not esta_incluido(numero, nueva_lista):
                nueva_lista.append(numero)

    return nueva_lista

def esta_incluido ( elemento : int, conjunto : list[int]) -&gt; bool:
    for elem in conjunto:
        if elem == elemento:
            return True
    return False

def cantidad_de_veces_que_dividie ( primo : int, lista_numeros: list[int]) -&gt; int:
    cantidad : int = 0

    for numero in lista_numeros:
        if numero % primo == 0:
            cantidad += 1

    return cantidad

v_test : list[int] = [40,30,15,49, 11, 121, 200, 53]
print(multiplos_de_primos(v_test))

#---------------------------------------------------------------------------------------------------------

# Ejercicio 2
def longitud_mas_grande(A: list[list[int]]) -&gt; int:
    lista_nueva : list[int] = []
    mayor : int = 0

    for a in A:
        longitud = longitud_mas_larga_de_una_lista(a)
        lista_nueva.append(longitud)

    mayor = obtener_numero_mayor(lista_nueva)

    return mayor

def longitud_mas_larga_de_una_lista ( lista_numeros : list[int]) -&gt; int:
    res: int = 0
    inicio_actual : int = 0
    inicio_temporal: int = 0

    if not (esta_incluido(1, lista_numeros)):
        return res

    for numero in lista_numeros:
        if numero == 1 and inicio_actual == 0:
            inicio_actual += 1
        elif numero == 1 and inicio_actual != 0:
            inicio_actual += 1
        elif numero != 1:
            if inicio_actual &gt; inicio_temporal:
                inicio_temporal = inicio_actual
            inicio_actual = 0
        elif inicio_actual &gt; inicio_temporal:
            inicio_temporal = inicio_actual

    if(inicio_actual &gt; inicio_temporal):
        inicio_temporal = inicio_actual

    res = inicio_temporal

    return res

def obtener_numero_mayor ( lista_numeros : list[int] ) -&gt; int:
    mayor_parcial = lista_numeros[0]

    for numero in lista_numeros:
        if numero &gt; mayor_parcial:
            mayor_parcial = numero

    return mayor_parcial

longitud_test : list[list[int]] = [[1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], [2], [2,11], [1541]]
print(longitud_mas_grande(longitud_test))

#---------------------------------------------------------------------------------------------------------

# Ejercicio 3
def resolver_cuentas(A: Pila[str]) -&gt; list[int]:
    pila_back_up : Pila[str] = Pila()
    res : list[int] = []

    while not A.empty():
        cuenta: str = A.get()
        pila_back_up.put(cuenta)

        res.append(resolver_operacion_aritmetica(cuenta))

    while not pila_back_up.empty():
        A.put(pila_back_up.get())

    return res

def esta_bien_formado ( s : str) -&gt; bool:
    largo_caracter : int = len(s)

    for i in range(largo_caracter):
        if not es_mas_menos_o_digitos(s[i]):
            return False

        if not es_un_digito(s[largo_caracter -1]):
            return False

    if hay_dos_operadores_juntos(s):
        return False

    return True

def es_mas_menos_o_digitos ( caracter : str ) -&gt; bool:
    digitos : list[str] = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;+&quot;, &quot;-&quot;]

    for digito in digitos:
        if digito == caracter:
            return True
    return False

def es_un_digito ( caracter : str) -&gt; bool:
    digitos : list[str] = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;]

    for digito in digitos:
        if caracter == digito:
            return True
    return False

def hay_dos_operadores_juntos ( s : str) -&gt; bool:
    contador : int = 0

    for r in s:
        if contador &gt; 1:
            return True

        if r == &quot;+&quot; or r == &quot;-&quot;:
            contador +=1

        else:
            contador = 0

    if contador &gt; 1:
        return True

    return False

def resolver_operacion_aritmetica ( s : str) -&gt; int:

    nueva_lista : list[str] = s_a_lista(s)

    suma_total : int = 0
    valor_lista_sumas: int = 0
    valor_lista_restas: int = 0

    lista_sumas: list[int] = []
    lista_restas: list[int] = []

    esSuma : bool = False
    esResta: bool = False

    for i in range(len(nueva_lista)):
        if i == 0 and int(nueva_lista[0]) &gt;= 0:
            lista_sumas.append(int(nueva_lista[0]))
        elif i == 0 and int(nueva_lista[0]) &lt; 0:
            lista_restas.append(int(nueva_lista[0])* -1)          
        elif i != 0 and nueva_lista[i] == &quot;+&quot;:
            esSuma = True
            esResta = False
        elif i != 0 and nueva_lista[i] == &quot;-&quot;:
            esSuma = False
            esResta = True            
        elif esSuma:
            lista_sumas.append(int(nueva_lista[i]))
            esSuma = False
            esResta = False 
        elif esResta:
            lista_restas.append(int(nueva_lista[i]))
            esSuma = False
            esResta = False             

    for elem in lista_sumas:
        valor_lista_sumas += elem            

    for elem in lista_restas:
        valor_lista_restas += elem

    suma_total = valor_lista_sumas - valor_lista_restas

    return suma_total

def s_a_lista (s : str) -&gt; list[str]:
    res : str[int] = []
    numero_parcial : str = &quot;&quot;

    for i in range(len(s)):
        if i == 0 and es_un_digito(s[i]):
            numero_parcial += s[i]
        elif i != 0 and es_un_digito(s[i]):
            numero_parcial += s[i]
        elif i != 0 and not es_un_digito(s[i]):
            res.append(numero_parcial)
            res.append(s[i])
            numero_parcial = &quot;&quot;
    res.append(numero_parcial)

    if s[0] == '-':
        res[0] = &quot;-&quot; + res[0]

    return res

pila_test : Pila[str] = Pila()
pila_test.put(&quot;1+2+3+4+5&quot;)
pila_test.put(&quot;1-2+3-4+5&quot;)
pila_test.put(&quot;-1+2-3-4-5&quot;)
pila_test.put(&quot;-100-100-100+5-100&quot;)
pila_test.put(&quot;-100-100-100+5-100&quot;)

print(resolver_cuentas(pila_test)) 

#---------------------------------------------------------------------------------------------------------

# Ejercicio 4
def dame_el_que_falta(s: list[tuple[int,int]]) -&gt; tuple[int,int]:
    maximo : int = obtener_maximo_tupla(s)
    tuplas_totales : list[tuple[int,int]] = generar_tuplas_combinatoria(maximo)
    res : tuple[int,int] = (1,1)

    for tupla in tuplas_totales:
        if not esta_la_tupla_incluida(tupla, s):
            res = tupla
    return res

def obtener_maximo_tupla (tupla : list[tuple[int,int]]) -&gt; int:
    maximo_primera_componente : int = tupla[0][0]
    maximo_segunda_componene : int = tupla[0][1]
    res : int = 0

    for i in range(len(tupla)):
        if tupla[i][0] &gt; maximo_primera_componente:
            maximo_primera_componente = tupla[i][0]
        if tupla[i][1] &gt; maximo_segunda_componene:
            maximo_segunda_componene = tupla[i][1]

    if maximo_primera_componente &gt; maximo_segunda_componene:
        res = maximo_primera_componente
    else:
        res = maximo_segunda_componene

    return res

def esta_la_tupla_incluida ( tupla: tuple[int,int], tuplas : list[tuple[int,int]]) -&gt; bool:

    for tup in tuplas:
        if tup == tupla:
            return True
    return False

def generar_tuplas_combinatoria (maximo: int) -&gt; list[tuple[int,int]]:
    tuplas : list[tuple[int,int]] = []

    for i in range(1, maximo +1):
        for j in range(1, maximo +1):
            tuplas.append((i,j))

    return tuplas

s_test = [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (5, 1), (5, 2), (5, 3), (5,4), (5, 5), (5, 6), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]
print(dame_el_que_falta(s_test))


</code></pre>
<h2>Resultado de la compilacion</h2>
<pre><code>
</code></pre>
<h2>Ejecucion de los tests</h2>
<h3>tema1-test-ej1.py.compilacion.out</h3>
<p>Puntaje del ej: 2.25 / 2.25</p>
<pre><code>test_ej1_cero_elementos (__main__.Ej1Test.test_ej1_cero_elementos) ... ok
test_ej1_dos_elementos (__main__.Ej1Test.test_ej1_dos_elementos) ... ok
test_ej1_elementos_con_factores_repetidos (__main__.Ej1Test.test_ej1_elementos_con_factores_repetidos) ... ok
test_ej1_elementos_con_varios_factores_repetidos (__main__.Ej1Test.test_ej1_elementos_con_varios_factores_repetidos) ... ok
test_ej1_lista_con_un_uno (__main__.Ej1Test.test_ej1_lista_con_un_uno) ... ok
test_ej1_muchisimos_numeros (__main__.Ej1Test.test_ej1_muchisimos_numeros) ... ok
test_ej1_muchos_numeros (__main__.Ej1Test.test_ej1_muchos_numeros) ... ok
test_ej1_un_elemento (__main__.Ej1Test.test_ej1_un_elemento) ... ok

----------------------------------------------------------------------
Ran 8 tests in 0.011s

OK

</code></pre>
<h3>tema1-test-ej2.py.compilacion.out</h3>
<p>Puntaje del ej: 2.25 / 2.25</p>
<pre><code>test_ej2_muchas_listas (__main__.Ej1Test.test_ej2_muchas_listas) ... ok
test_ej2_una_lista_un_uno (__main__.Ej1Test.test_ej2_una_lista_un_uno) ... ok
test_ej2_una_lista_varias_secuencias_de_unos (__main__.Ej1Test.test_ej2_una_lista_varias_secuencias_de_unos) ... ok
test_ej2_una_lista_varios_unos (__main__.Ej1Test.test_ej2_una_lista_varios_unos) ... ok
test_ej2_varias_listas_max_al_final (__main__.Ej1Test.test_ej2_varias_listas_max_al_final) ... ok
test_ej2_varias_listas_max_al_principio (__main__.Ej1Test.test_ej2_varias_listas_max_al_principio) ... ok

----------------------------------------------------------------------
Ran 6 tests in 0.004s

OK

</code></pre>
<h3>tema1-test-ej3.py.compilacion.out</h3>
<p>Puntaje del ej: 2.25 / 2.25</p>
<pre><code>test_ej3_cuentas_que_empiezan_con_mas (__main__.Ej1Test.test_ej3_cuentas_que_empiezan_con_mas) ... ok
test_ej3_cuentas_que_empiezan_con_menos (__main__.Ej1Test.test_ej3_cuentas_que_empiezan_con_menos) ... ok
test_ej3_dos_cuentas_preserva_pila (__main__.Ej1Test.test_ej3_dos_cuentas_preserva_pila) ... ok
test_ej3_pila_vacia (__main__.Ej1Test.test_ej3_pila_vacia) ... ok
test_ej3_una_cuenta (__main__.Ej1Test.test_ej3_una_cuenta) ... ok
test_ej3_varias_cuentas (__main__.Ej1Test.test_ej3_varias_cuentas) ... ok

----------------------------------------------------------------------
Ran 6 tests in 0.005s

OK

</code></pre>
<h3>tema1-test-ej4.py.compilacion.out</h3>
<p>Puntaje del ej: 2.25 / 2.25</p>
<pre><code>test_ej4_falta_el_mas_chico (__main__.Ej1Test.test_ej4_falta_el_mas_chico) ... ok
test_ej4_falta_el_mas_grande (__main__.Ej1Test.test_ej4_falta_el_mas_grande) ... ok
test_ej4_lista_mas_larga (__main__.Ej1Test.test_ej4_lista_mas_larga) ... ok
test_ej4_lista_simple (__main__.Ej1Test.test_ej4_lista_simple) ... ok
test_ej4_test_grande_desordenado (__main__.Ej1Test.test_ej4_test_grande_desordenado) ... ok
test_ej4_test_grande_ordenado (__main__.Ej1Test.test_ej4_test_grande_ordenado) ... ok

----------------------------------------------------------------------
Ran 6 tests in 0.005s

OK

</code></pre>
<h3>mchoice.json-ej5.compilacion.out</h3>
<p>Puntaje del ej: 1 / 1</p>
<pre><code>mchoice ej5: respuesta del alumno=3, respuesta correcta=3

Ran 1 test in 0 seconds

OK

</code></pre>
<p>FIN</p>